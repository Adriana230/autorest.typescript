/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { ManagementLocks } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { ManagementLockClient } from "../managementLockClient";
import {
  ManagementLockObject,
  ManagementLocksListAtResourceGroupLevelNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelOptionalParams,
  ManagementLocksListAtResourceLevelNextOptionalParams,
  ManagementLocksListAtResourceLevelOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelOptionalParams,
  ManagementLocksListByScopeNextOptionalParams,
  ManagementLocksListByScopeOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextOptionalParams,
  ManagementLocksListByScopeNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksListByScopeNextNextNextNextNextNextNextNextOptionalParams,
  ManagementLocksCreateOrUpdateAtResourceGroupLevelOptionalParams,
  ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse,
  ManagementLocksDeleteAtResourceGroupLevelOptionalParams,
  ManagementLocksGetAtResourceGroupLevelOptionalParams,
  ManagementLocksGetAtResourceGroupLevelResponse,
  ManagementLocksCreateOrUpdateByScopeOptionalParams,
  ManagementLocksCreateOrUpdateByScopeResponse,
  ManagementLocksDeleteByScopeOptionalParams,
  ManagementLocksGetByScopeOptionalParams,
  ManagementLocksGetByScopeResponse,
  ManagementLocksCreateOrUpdateAtResourceLevelOptionalParams,
  ManagementLocksCreateOrUpdateAtResourceLevelResponse,
  ManagementLocksDeleteAtResourceLevelOptionalParams,
  ManagementLocksGetAtResourceLevelOptionalParams,
  ManagementLocksGetAtResourceLevelResponse,
  ManagementLocksCreateOrUpdateAtSubscriptionLevelOptionalParams,
  ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse,
  ManagementLocksDeleteAtSubscriptionLevelOptionalParams,
  ManagementLocksGetAtSubscriptionLevelOptionalParams,
  ManagementLocksGetAtSubscriptionLevelResponse,
  ManagementLocksListAtResourceGroupLevelResponse,
  ManagementLocksListAtResourceLevelResponse,
  ManagementLocksListAtSubscriptionLevelResponse,
  ManagementLocksListByScopeResponse,
  ManagementLocksListAtResourceGroupLevelNextResponse,
  ManagementLocksListAtResourceLevelNextResponse,
  ManagementLocksListAtSubscriptionLevelNextResponse,
  ManagementLocksListByScopeNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextResponse,
  ManagementLocksListByScopeNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextNextNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextNextNextNextNextResponse,
  ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextNextResponse,
  ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextNextResponse,
  ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextNextResponse,
  ManagementLocksListByScopeNextNextNextNextNextNextNextNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing ManagementLocks operations. */
export class ManagementLocksImpl implements ManagementLocks {
  private readonly client: ManagementLockClient;

  /**
   * Initialize a new instance of the class ManagementLocks class.
   * @param client Reference to the service client
   */
  constructor(client: ManagementLockClient) {
    this.client = client;
  }

  /**
   * Gets all the management locks for a resource group.
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevel(
    resourceGroupName: string,
    options?: ManagementLocksListAtResourceGroupLevelOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelPagingAll(
      resourceGroupName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelPagingPage(
          resourceGroupName,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelPagingPage(
    resourceGroupName: string,
    options?: ManagementLocksListAtResourceGroupLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevel(
      resourceGroupName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelPagingAll(
    resourceGroupName: string,
    options?: ManagementLocksListAtResourceGroupLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelPagingPage(
      resourceGroupName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Gets all the management locks for a resource or any level below resource.
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param options The options parameters.
   */
  public listAtResourceLevel(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    options?: ManagementLocksListAtResourceLevelOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    options?: ManagementLocksListAtResourceLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevel(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    options?: ManagementLocksListAtResourceLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Gets all the management locks for a subscription.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevel(
    options?: ManagementLocksListAtSubscriptionLevelOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelPagingPage(options);
      }
    };
  }

  private async *listAtSubscriptionLevelPagingPage(
    options?: ManagementLocksListAtSubscriptionLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevel(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelPagingAll(
    options?: ManagementLocksListAtSubscriptionLevelOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Gets all the management locks for a scope.
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param options The options parameters.
   */
  public listByScope(
    scope: string,
    options?: ManagementLocksListByScopeOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopePagingAll(scope, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopePagingPage(scope, options);
      }
    };
  }

  private async *listByScopePagingPage(
    scope: string,
    options?: ManagementLocksListByScopeOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScope(scope, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNext(scope, continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopePagingAll(
    scope: string,
    options?: ManagementLocksListByScopeOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopePagingPage(scope, options)) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceGroupLevel
   *                 method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevel method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNext
   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionLevel
   *                 method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextPagingAll(nextLink, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextPagingPage(nextLink, options);
      }
    };
  }

  private async *listAtSubscriptionLevelNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNext(nextLink, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScope method.
   * @param options The options parameters.
   */
  public listByScopeNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextPagingAll(scope, nextLink, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextPagingPage(scope, nextLink, options);
      }
    };
  }

  private async *listByScopeNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNext(scope, nextLink, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceGroupLevelNext
   *                 method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevelNext
   *                 method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNext
   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionLevelNext
   *                 method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNext(nextLink, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNext method.
   * @param options The options parameters.
   */
  public listByScopeNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextPagingAll(scope, nextLink, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextPagingPage(scope, nextLink, options);
      }
    };
  }

  private async *listByScopeNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNext(scope, nextLink, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevelNextNext
   *                 method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNext method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNextNext(
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNext method.
   * @param options The options parameters.
   */
  public listByScopeNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextNextPagingAll(
      scope,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextNextPagingPage(scope, nextLink, options);
      }
    };
  }

  private async *listByScopeNextNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNextNext(scope, nextLink, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNextNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNextNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNext method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNextNextNext(
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNextNext
   *                 method.
   * @param options The options parameters.
   */
  public listByScopeNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextNextNextPagingAll(
      scope,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextNextNextPagingPage(
          scope,
          nextLink,
          options
        );
      }
    };
  }

  private async *listByScopeNextNextNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNextNextNext(
      scope,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextNextNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextNextNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNextNextNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNextNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextNextNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextNextNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextNextNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNextNextNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNextNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextNextNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextNextNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextNextNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNextNextNextNext(
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNextNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextNextNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNextNextNext
   *                 method.
   * @param options The options parameters.
   */
  public listByScopeNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextNextNextNextPagingAll(
      scope,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextNextNextNextPagingPage(
          scope,
          nextLink,
          options
        );
      }
    };
  }

  private async *listByScopeNextNextNextNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNextNextNextNext(
      scope,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNextNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextNextNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextNextNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextNextNextNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextNextNextNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNextNextNextNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNextNextNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextNextNextNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextNextNextNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextNextNextNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNextNextNextNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNextNextNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextNextNextNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextNextNextNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextNextNextNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNextNextNextNextNext(
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNextNextNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextNextNextNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByScopeNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listByScopeNextNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextNextNextNextNextPagingAll(
      scope,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextNextNextNextNextPagingPage(
          scope,
          nextLink,
          options
        );
      }
    };
  }

  private async *listByScopeNextNextNextNextNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNextNextNextNextNext(
      scope,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNextNextNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextNextNextNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextNextNextNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceGroupLevelNextNextNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceGroupLevelNextNextNextNextNextNextNextPagingAll(
      resourceGroupName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceGroupLevelNextNextNextNextNextNextNextPagingPage(
          resourceGroupName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceGroupLevelNextNextNextNextNextNextNext(
      resourceGroupName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceGroupLevelNextNextNextNextNextNextNextNext(
        resourceGroupName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceGroupLevelNextNextNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceGroupLevelNextNextNextNextNextNextNextPagingPage(
      resourceGroupName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtResourceLevelNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtResourceLevelNextNextNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtResourceLevelNextNextNextNextNextNextNextPagingAll(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtResourceLevelNextNextNextNextNextNextNextPagingPage(
          resourceGroupName,
          resourceProviderNamespace,
          parentResourcePath,
          resourceType,
          resourceName,
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtResourceLevelNextNextNextNextNextNextNextPagingPage(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtResourceLevelNextNextNextNextNextNextNext(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtResourceLevelNextNextNextNextNextNextNextNext(
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtResourceLevelNextNextNextNextNextNextNextPagingAll(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtResourceLevelNextNextNextNextNextNextNextPagingPage(
      resourceGroupName,
      resourceProviderNamespace,
      parentResourcePath,
      resourceType,
      resourceName,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listAtSubscriptionLevelNextNextNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listAtSubscriptionLevelNextNextNextNextNextNextNextPagingAll(
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listAtSubscriptionLevelNextNextNextNextNextNextNextPagingPage(
          nextLink,
          options
        );
      }
    };
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextNextNextPagingPage(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listAtSubscriptionLevelNextNextNextNextNextNextNext(
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listAtSubscriptionLevelNextNextNextNextNextNextNextNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listAtSubscriptionLevelNextNextNextNextNextNextNextPagingAll(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listAtSubscriptionLevelNextNextNextNextNextNextNextPagingPage(
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * ListByScopeNextNextNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByScopeNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  public listByScopeNextNextNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextNextOptionalParams
  ): PagedAsyncIterableIterator<ManagementLockObject> {
    const iter = this.listByScopeNextNextNextNextNextNextNextPagingAll(
      scope,
      nextLink,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByScopeNextNextNextNextNextNextNextPagingPage(
          scope,
          nextLink,
          options
        );
      }
    };
  }

  private async *listByScopeNextNextNextNextNextNextNextPagingPage(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject[]> {
    let result = await this._listByScopeNextNextNextNextNextNextNext(
      scope,
      nextLink,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByScopeNextNextNextNextNextNextNextNext(
        scope,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByScopeNextNextNextNextNextNextNextPagingAll(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextNextOptionalParams
  ): AsyncIterableIterator<ManagementLockObject> {
    for await (const page of this.listByScopeNextNextNextNextNextNextNextPagingPage(
      scope,
      nextLink,
      options
    )) {
      yield* page;
    }
  }

  /**
   * When you apply a lock at a parent scope, all child resources inherit the same lock. To create
   * management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param resourceGroupName The name of the resource group to lock.
   * @param lockName The lock name. The lock name can be a maximum of 260 characters. It cannot contain
   *                 <, > %, &, :, \, ?, /, or any control characters.
   * @param parameters The management lock parameters.
   * @param options The options parameters.
   */
  createOrUpdateAtResourceGroupLevel(
    resourceGroupName: string,
    lockName: string,
    parameters: ManagementLockObject,
    options?: ManagementLocksCreateOrUpdateAtResourceGroupLevelOptionalParams
  ): Promise<ManagementLocksCreateOrUpdateAtResourceGroupLevelResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, lockName, parameters, options },
      createOrUpdateAtResourceGroupLevelOperationSpec
    );
  }

  /**
   * To delete management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param resourceGroupName The name of the resource group containing the lock.
   * @param lockName The name of lock to delete.
   * @param options The options parameters.
   */
  deleteAtResourceGroupLevel(
    resourceGroupName: string,
    lockName: string,
    options?: ManagementLocksDeleteAtResourceGroupLevelOptionalParams
  ): Promise<void> {
    return this.client.sendOperationRequest(
      { resourceGroupName, lockName, options },
      deleteAtResourceGroupLevelOperationSpec
    );
  }

  /**
   * Gets a management lock at the resource group level.
   * @param resourceGroupName The name of the locked resource group.
   * @param lockName The name of the lock to get.
   * @param options The options parameters.
   */
  getAtResourceGroupLevel(
    resourceGroupName: string,
    lockName: string,
    options?: ManagementLocksGetAtResourceGroupLevelOptionalParams
  ): Promise<ManagementLocksGetAtResourceGroupLevelResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, lockName, options },
      getAtResourceGroupLevelOperationSpec
    );
  }

  /**
   * Create or update a management lock by scope.
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param lockName The name of lock.
   * @param parameters Create or update management lock parameters.
   * @param options The options parameters.
   */
  createOrUpdateByScope(
    scope: string,
    lockName: string,
    parameters: ManagementLockObject,
    options?: ManagementLocksCreateOrUpdateByScopeOptionalParams
  ): Promise<ManagementLocksCreateOrUpdateByScopeResponse> {
    return this.client.sendOperationRequest(
      { scope, lockName, parameters, options },
      createOrUpdateByScopeOperationSpec
    );
  }

  /**
   * Delete a management lock by scope.
   * @param scope The scope for the lock.
   * @param lockName The name of lock.
   * @param options The options parameters.
   */
  deleteByScope(
    scope: string,
    lockName: string,
    options?: ManagementLocksDeleteByScopeOptionalParams
  ): Promise<void> {
    return this.client.sendOperationRequest(
      { scope, lockName, options },
      deleteByScopeOperationSpec
    );
  }

  /**
   * Get a management lock by scope.
   * @param scope The scope for the lock.
   * @param lockName The name of lock.
   * @param options The options parameters.
   */
  getByScope(
    scope: string,
    lockName: string,
    options?: ManagementLocksGetByScopeOptionalParams
  ): Promise<ManagementLocksGetByScopeResponse> {
    return this.client.sendOperationRequest(
      { scope, lockName, options },
      getByScopeOperationSpec
    );
  }

  /**
   * When you apply a lock at a parent scope, all child resources inherit the same lock. To create
   * management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param resourceGroupName The name of the resource group containing the resource to lock.
   * @param resourceProviderNamespace The resource provider namespace of the resource to lock.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the resource to lock.
   * @param resourceName The name of the resource to lock.
   * @param lockName The name of lock. The lock name can be a maximum of 260 characters. It cannot
   *                 contain <, > %, &, :, \, ?, /, or any control characters.
   * @param parameters Parameters for creating or updating a  management lock.
   * @param options The options parameters.
   */
  createOrUpdateAtResourceLevel(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    lockName: string,
    parameters: ManagementLockObject,
    options?: ManagementLocksCreateOrUpdateAtResourceLevelOptionalParams
  ): Promise<ManagementLocksCreateOrUpdateAtResourceLevelResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        lockName,
        parameters,
        options
      },
      createOrUpdateAtResourceLevelOperationSpec
    );
  }

  /**
   * To delete management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param resourceGroupName The name of the resource group containing the resource with the lock to
   *                          delete.
   * @param resourceProviderNamespace The resource provider namespace of the resource with the lock to
   *                                  delete.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the resource with the lock to delete.
   * @param resourceName The name of the resource with the lock to delete.
   * @param lockName The name of the lock to delete.
   * @param options The options parameters.
   */
  deleteAtResourceLevel(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    lockName: string,
    options?: ManagementLocksDeleteAtResourceLevelOptionalParams
  ): Promise<void> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        lockName,
        options
      },
      deleteAtResourceLevelOperationSpec
    );
  }

  /**
   * Get the management lock of a resource or any level below resource.
   * @param resourceGroupName The name of the resource group.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath An extra path parameter needed in some services, like SQL Databases.
   * @param resourceType The type of the resource.
   * @param resourceName The name of the resource.
   * @param lockName The name of lock.
   * @param options The options parameters.
   */
  getAtResourceLevel(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    lockName: string,
    options?: ManagementLocksGetAtResourceLevelOptionalParams
  ): Promise<ManagementLocksGetAtResourceLevelResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        lockName,
        options
      },
      getAtResourceLevelOperationSpec
    );
  }

  /**
   * When you apply a lock at a parent scope, all child resources inherit the same lock. To create
   * management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param lockName The name of lock. The lock name can be a maximum of 260 characters. It cannot
   *                 contain <, > %, &, :, \, ?, /, or any control characters.
   * @param parameters The management lock parameters.
   * @param options The options parameters.
   */
  createOrUpdateAtSubscriptionLevel(
    lockName: string,
    parameters: ManagementLockObject,
    options?: ManagementLocksCreateOrUpdateAtSubscriptionLevelOptionalParams
  ): Promise<ManagementLocksCreateOrUpdateAtSubscriptionLevelResponse> {
    return this.client.sendOperationRequest(
      { lockName, parameters, options },
      createOrUpdateAtSubscriptionLevelOperationSpec
    );
  }

  /**
   * To delete management locks, you must have access to Microsoft.Authorization/* or
   * Microsoft.Authorization/locks/* actions. Of the built-in roles, only Owner and User Access
   * Administrator are granted those actions.
   * @param lockName The name of lock to delete.
   * @param options The options parameters.
   */
  deleteAtSubscriptionLevel(
    lockName: string,
    options?: ManagementLocksDeleteAtSubscriptionLevelOptionalParams
  ): Promise<void> {
    return this.client.sendOperationRequest(
      { lockName, options },
      deleteAtSubscriptionLevelOperationSpec
    );
  }

  /**
   * Gets a management lock at the subscription level.
   * @param lockName The name of the lock to get.
   * @param options The options parameters.
   */
  getAtSubscriptionLevel(
    lockName: string,
    options?: ManagementLocksGetAtSubscriptionLevelOptionalParams
  ): Promise<ManagementLocksGetAtSubscriptionLevelResponse> {
    return this.client.sendOperationRequest(
      { lockName, options },
      getAtSubscriptionLevelOperationSpec
    );
  }

  /**
   * Gets all the management locks for a resource group.
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevel(
    resourceGroupName: string,
    options?: ManagementLocksListAtResourceGroupLevelOptionalParams
  ): Promise<ManagementLocksListAtResourceGroupLevelResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, options },
      listAtResourceGroupLevelOperationSpec
    );
  }

  /**
   * Gets all the management locks for a resource or any level below resource.
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param options The options parameters.
   */
  private _listAtResourceLevel(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    options?: ManagementLocksListAtResourceLevelOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        options
      },
      listAtResourceLevelOperationSpec
    );
  }

  /**
   * Gets all the management locks for a subscription.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevel(
    options?: ManagementLocksListAtSubscriptionLevelOptionalParams
  ): Promise<ManagementLocksListAtSubscriptionLevelResponse> {
    return this.client.sendOperationRequest(
      { options },
      listAtSubscriptionLevelOperationSpec
    );
  }

  /**
   * Gets all the management locks for a scope.
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param options The options parameters.
   */
  private _listByScope(
    scope: string,
    options?: ManagementLocksListByScopeOptionalParams
  ): Promise<ManagementLocksListByScopeResponse> {
    return this.client.sendOperationRequest(
      { scope, options },
      listByScopeOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceGroupLevel
   *                 method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextOptionalParams
  ): Promise<ManagementLocksListAtResourceGroupLevelNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevel method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNext
   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionLevel
   *                 method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextOptionalParams
  ): Promise<ManagementLocksListAtSubscriptionLevelNextResponse> {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextOperationSpec
    );
  }

  /**
   * ListByScopeNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScope method.
   * @param options The options parameters.
   */
  private _listByScopeNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceGroupLevelNext
   *                 method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceGroupLevelNextNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevelNext
   *                 method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelNextNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNext
   * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionLevelNext
   *                 method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextOptionalParams
  ): Promise<ManagementLocksListAtSubscriptionLevelNextNextResponse> {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNext method.
   * @param options The options parameters.
   */
  private _listByScopeNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceGroupLevelNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the ListAtResourceLevelNextNext
   *                 method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelNextNextNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtSubscriptionLevelNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNext method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceGroupLevelNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtSubscriptionLevelNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNextNext
   *                 method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceGroupLevelNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListAtResourceLevelNextNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtSubscriptionLevelNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the ListByScopeNextNextNextNext
   *                 method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceLevelNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByScopeNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByScopeNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextNextOptionalParams
  ): Promise<ManagementLocksListByScopeNextNextNextNextNextNextNextResponse> {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceGroupLevelNextNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locks to get.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceGroupLevelNextNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceGroupLevelNextNextNextNextNextNextNextNext(
    resourceGroupName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceGroupLevelNextNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { resourceGroupName, nextLink, options },
      listAtResourceGroupLevelNextNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtResourceLevelNextNextNextNextNextNextNextNext
   * @param resourceGroupName The name of the resource group containing the locked resource. The name is
   *                          case insensitive.
   * @param resourceProviderNamespace The namespace of the resource provider.
   * @param parentResourcePath The parent resource identity.
   * @param resourceType The resource type of the locked resource.
   * @param resourceName The name of the locked resource.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtResourceLevelNextNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtResourceLevelNextNextNextNextNextNextNextNext(
    resourceGroupName: string,
    resourceProviderNamespace: string,
    parentResourcePath: string,
    resourceType: string,
    resourceName: string,
    nextLink: string,
    options?: ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtResourceLevelNextNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceProviderNamespace,
        parentResourcePath,
        resourceType,
        resourceName,
        nextLink,
        options
      },
      listAtResourceLevelNextNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListAtSubscriptionLevelNextNextNextNextNextNextNextNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListAtSubscriptionLevelNextNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listAtSubscriptionLevelNextNextNextNextNextNextNextNext(
    nextLink: string,
    options?: ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListAtSubscriptionLevelNextNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listAtSubscriptionLevelNextNextNextNextNextNextNextNextOperationSpec
    );
  }

  /**
   * ListByScopeNextNextNextNextNextNextNextNext
   * @param scope The scope for the lock. When providing a scope for the assignment, use
   *              '/subscriptions/{subscriptionId}' for subscriptions,
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}' for resource groups, and
   *              '/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePathIfPresent}/{resourceType}/{resourceName}'
   *              for resources.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByScopeNextNextNextNextNextNextNext method.
   * @param options The options parameters.
   */
  private _listByScopeNextNextNextNextNextNextNextNext(
    scope: string,
    nextLink: string,
    options?: ManagementLocksListByScopeNextNextNextNextNextNextNextNextOptionalParams
  ): Promise<
    ManagementLocksListByScopeNextNextNextNextNextNextNextNextResponse
  > {
    return this.client.sendOperationRequest(
      { scope, nextLink, options },
      listByScopeNextNextNextNextNextNextNextNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const createOrUpdateAtResourceGroupLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    },
    201: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  requestBody: Parameters.parameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteAtResourceGroupLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  serializer
};
const getAtResourceGroupLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createOrUpdateByScopeOperationSpec: coreClient.OperationSpec = {
  path: "/{scope}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    },
    201: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  requestBody: Parameters.parameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.$host, Parameters.lockName, Parameters.scope],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteByScopeOperationSpec: coreClient.OperationSpec = {
  path: "/{scope}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.$host, Parameters.lockName, Parameters.scope],
  serializer
};
const getByScopeOperationSpec: coreClient.OperationSpec = {
  path: "/{scope}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.$host, Parameters.lockName, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const createOrUpdateAtResourceLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    },
    201: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  requestBody: Parameters.parameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteAtResourceLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  serializer
};
const getAtResourceLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.lockName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createOrUpdateAtSubscriptionLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    },
    201: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  requestBody: Parameters.parameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteAtSubscriptionLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  serializer
};
const getAtSubscriptionLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks/{lockName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockObject
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.lockName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/locks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/locks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/locks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.subscriptionId],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeOperationSpec: coreClient.OperationSpec = {
  path: "/{scope}/providers/Microsoft.Authorization/locks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceGroupLevelNextNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtResourceLevelNextNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceProviderNamespace,
    Parameters.parentResourcePath,
    Parameters.resourceType,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listAtSubscriptionLevelNextNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByScopeNextNextNextNextNextNextNextNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ManagementLockListResult
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.filter],
  urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
  headerParameters: [Parameters.accept],
  serializer
};
