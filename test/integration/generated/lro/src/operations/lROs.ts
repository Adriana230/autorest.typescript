/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { LrOS } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { LroClient } from "../lroClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  LrOSPut200SucceededOptionalParams,
  LrOSPut200SucceededResponse,
  LrOSPatch200SucceededIgnoreHeadersOptionalParams,
  LrOSPatch200SucceededIgnoreHeadersResponse,
  LrOSPut201SucceededOptionalParams,
  LrOSPut201SucceededResponse,
  LrOSPost202ListOptionalParams,
  LrOSPost202ListResponse,
  LrOSPut200SucceededNoStateOptionalParams,
  LrOSPut200SucceededNoStateResponse,
  LrOSPut202Retry200OptionalParams,
  LrOSPut202Retry200Response,
  LrOSPut201CreatingSucceeded200OptionalParams,
  LrOSPut201CreatingSucceeded200Response,
  LrOSPut200UpdatingSucceeded204OptionalParams,
  LrOSPut200UpdatingSucceeded204Response,
  LrOSPut201CreatingFailed200OptionalParams,
  LrOSPut201CreatingFailed200Response,
  LrOSPut200Acceptedcanceled200OptionalParams,
  LrOSPut200Acceptedcanceled200Response,
  LrOSPutNoHeaderInRetryOptionalParams,
  LrOSPutNoHeaderInRetryResponse,
  LrOSPutAsyncRetrySucceededOptionalParams,
  LrOSPutAsyncRetrySucceededResponse,
  LrOSPutAsyncNoRetrySucceededOptionalParams,
  LrOSPutAsyncNoRetrySucceededResponse,
  LrOSPutAsyncRetryFailedOptionalParams,
  LrOSPutAsyncRetryFailedResponse,
  LrOSPutAsyncNoRetrycanceledOptionalParams,
  LrOSPutAsyncNoRetrycanceledResponse,
  LrOSPutAsyncNoHeaderInRetryOptionalParams,
  LrOSPutAsyncNoHeaderInRetryResponse,
  LrOSPutNonResourceOptionalParams,
  LrOSPutNonResourceResponse,
  LrOSPutAsyncNonResourceOptionalParams,
  LrOSPutAsyncNonResourceResponse,
  LrOSPutSubResourceOptionalParams,
  LrOSPutSubResourceResponse,
  LrOSPutAsyncSubResourceOptionalParams,
  LrOSPutAsyncSubResourceResponse,
  LrOSDeleteProvisioning202Accepted200SucceededOptionalParams,
  LrOSDeleteProvisioning202Accepted200SucceededResponse,
  LrOSDeleteProvisioning202DeletingFailed200OptionalParams,
  LrOSDeleteProvisioning202DeletingFailed200Response,
  LrOSDeleteProvisioning202Deletingcanceled200OptionalParams,
  LrOSDeleteProvisioning202Deletingcanceled200Response,
  LrOSDelete204SucceededOptionalParams,
  LrOSDelete202Retry200OptionalParams,
  LrOSDelete202Retry200Response,
  LrOSDelete202NoRetry204OptionalParams,
  LrOSDelete202NoRetry204Response,
  LrOSDeleteNoHeaderInRetryOptionalParams,
  LrOSDeleteNoHeaderInRetryResponse,
  LrOSDeleteAsyncNoHeaderInRetryOptionalParams,
  LrOSDeleteAsyncNoHeaderInRetryResponse,
  LrOSDeleteAsyncRetrySucceededOptionalParams,
  LrOSDeleteAsyncRetrySucceededResponse,
  LrOSDeleteAsyncNoRetrySucceededOptionalParams,
  LrOSDeleteAsyncNoRetrySucceededResponse,
  LrOSDeleteAsyncRetryFailedOptionalParams,
  LrOSDeleteAsyncRetryFailedResponse,
  LrOSDeleteAsyncRetrycanceledOptionalParams,
  LrOSDeleteAsyncRetrycanceledResponse,
  LrOSPost200WithPayloadOptionalParams,
  LrOSPost200WithPayloadResponse,
  LrOSPost202Retry200OptionalParams,
  LrOSPost202Retry200Response,
  LrOSPost202NoRetry204OptionalParams,
  LrOSPost202NoRetry204Response,
  LrOSPostDoubleHeadersFinalLocationGetOptionalParams,
  LrOSPostDoubleHeadersFinalLocationGetResponse,
  LrOSPostDoubleHeadersFinalAzureHeaderGetOptionalParams,
  LrOSPostDoubleHeadersFinalAzureHeaderGetResponse,
  LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams,
  LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultResponse,
  LrOSPostAsyncRetrySucceededOptionalParams,
  LrOSPostAsyncRetrySucceededResponse,
  LrOSPostAsyncNoRetrySucceededOptionalParams,
  LrOSPostAsyncNoRetrySucceededResponse,
  LrOSPostAsyncRetryFailedOptionalParams,
  LrOSPostAsyncRetryFailedResponse,
  LrOSPostAsyncRetrycanceledOptionalParams,
  LrOSPostAsyncRetrycanceledResponse
} from "../models";

/** Class containing LrOS operations. */
export class LrOSImpl implements LrOS {
  private readonly client: LroClient;

  /**
   * Initialize a new instance of the class LrOS class.
   * @param client Reference to the service client
   */
  constructor(client: LroClient) {
    this.client = client;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200Succeeded(
    options?: LrOSPut200SucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut200SucceededResponse>,
      LrOSPut200SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut200SucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put200SucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededAndWait(
    options?: LrOSPut200SucceededOptionalParams
  ): Promise<LrOSPut200SucceededResponse> {
    const poller = await this.beginPut200Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request with location header. We
   * should not have any subsequent calls after receiving this first response.
   * @param options The options parameters.
   */
  async beginPatch200SucceededIgnoreHeaders(
    options?: LrOSPatch200SucceededIgnoreHeadersOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPatch200SucceededIgnoreHeadersResponse>,
      LrOSPatch200SucceededIgnoreHeadersResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPatch200SucceededIgnoreHeadersResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      patch200SucceededIgnoreHeadersOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request with location header. We
   * should not have any subsequent calls after receiving this first response.
   * @param options The options parameters.
   */
  async beginPatch200SucceededIgnoreHeadersAndWait(
    options?: LrOSPatch200SucceededIgnoreHeadersOptionalParams
  ): Promise<LrOSPatch200SucceededIgnoreHeadersResponse> {
    const poller = await this.beginPatch200SucceededIgnoreHeaders(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut201Succeeded(
    options?: LrOSPut201SucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut201SucceededResponse>,
      LrOSPut201SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut201SucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put201SucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut201SucceededAndWait(
    options?: LrOSPut201SucceededOptionalParams
  ): Promise<LrOSPut201SucceededResponse> {
    const poller = await this.beginPut201Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 with empty body to first request, returns a 200 with
   * body [{ 'id': '100', 'name': 'foo' }].
   * @param options The options parameters.
   */
  async beginPost202List(
    options?: LrOSPost202ListOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPost202ListResponse>,
      LrOSPost202ListResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPost202ListResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202ListOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 202 with empty body to first request, returns a 200 with
   * body [{ 'id': '100', 'name': 'foo' }].
   * @param options The options parameters.
   */
  async beginPost202ListAndWait(
    options?: LrOSPost202ListOptionalParams
  ): Promise<LrOSPost202ListResponse> {
    const poller = await this.beginPost202List(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that does not
   * contain ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededNoState(
    options?: LrOSPut200SucceededNoStateOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut200SucceededNoStateResponse>,
      LrOSPut200SucceededNoStateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut200SucceededNoStateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put200SucceededNoStateOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that does not
   * contain ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededNoStateAndWait(
    options?: LrOSPut200SucceededNoStateOptionalParams
  ): Promise<LrOSPut200SucceededNoStateResponse> {
    const poller = await this.beginPut200SucceededNoState(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request, with a location header that
   * points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
   * @param options The options parameters.
   */
  async beginPut202Retry200(
    options?: LrOSPut202Retry200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut202Retry200Response>,
      LrOSPut202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut202Retry200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put202Retry200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request, with a location header that
   * points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
   * @param options The options parameters.
   */
  async beginPut202Retry200AndWait(
    options?: LrOSPut202Retry200OptionalParams
  ): Promise<LrOSPut202Retry200Response> {
    const poller = await this.beginPut202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut201CreatingSucceeded200(
    options?: LrOSPut201CreatingSucceeded200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut201CreatingSucceeded200Response>,
      LrOSPut201CreatingSucceeded200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut201CreatingSucceeded200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put201CreatingSucceeded200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut201CreatingSucceeded200AndWait(
    options?: LrOSPut201CreatingSucceeded200OptionalParams
  ): Promise<LrOSPut201CreatingSucceeded200Response> {
    const poller = await this.beginPut201CreatingSucceeded200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut200UpdatingSucceeded204(
    options?: LrOSPut200UpdatingSucceeded204OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut200UpdatingSucceeded204Response>,
      LrOSPut200UpdatingSucceeded204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut200UpdatingSucceeded204Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put200UpdatingSucceeded204OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut200UpdatingSucceeded204AndWait(
    options?: LrOSPut200UpdatingSucceeded204OptionalParams
  ): Promise<LrOSPut200UpdatingSucceeded204Response> {
    const poller = await this.beginPut200UpdatingSucceeded204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginPut201CreatingFailed200(
    options?: LrOSPut201CreatingFailed200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut201CreatingFailed200Response>,
      LrOSPut201CreatingFailed200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut201CreatingFailed200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put201CreatingFailed200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginPut201CreatingFailed200AndWait(
    options?: LrOSPut201CreatingFailed200OptionalParams
  ): Promise<LrOSPut201CreatingFailed200Response> {
    const poller = await this.beginPut201CreatingFailed200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginPut200Acceptedcanceled200(
    options?: LrOSPut200Acceptedcanceled200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPut200Acceptedcanceled200Response>,
      LrOSPut200Acceptedcanceled200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPut200Acceptedcanceled200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put200Acceptedcanceled200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginPut200Acceptedcanceled200AndWait(
    options?: LrOSPut200Acceptedcanceled200OptionalParams
  ): Promise<LrOSPut200Acceptedcanceled200Response> {
    const poller = await this.beginPut200Acceptedcanceled200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request with location header.
   * Subsequent calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginPutNoHeaderInRetry(
    options?: LrOSPutNoHeaderInRetryOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutNoHeaderInRetryResponse>,
      LrOSPutNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutNoHeaderInRetryResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putNoHeaderInRetryOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request with location header.
   * Subsequent calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginPutNoHeaderInRetryAndWait(
    options?: LrOSPutNoHeaderInRetryOptionalParams
  ): Promise<LrOSPutNoHeaderInRetryResponse> {
    const poller = await this.beginPutNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetrySucceeded(
    options?: LrOSPutAsyncRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncRetrySucceededResponse>,
      LrOSPutAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetrySucceededAndWait(
    options?: LrOSPutAsyncRetrySucceededOptionalParams
  ): Promise<LrOSPutAsyncRetrySucceededResponse> {
    const poller = await this.beginPutAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrySucceeded(
    options?: LrOSPutAsyncNoRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncNoRetrySucceededResponse>,
      LrOSPutAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncNoRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncNoRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrySucceededAndWait(
    options?: LrOSPutAsyncNoRetrySucceededOptionalParams
  ): Promise<LrOSPutAsyncNoRetrySucceededResponse> {
    const poller = await this.beginPutAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetryFailed(
    options?: LrOSPutAsyncRetryFailedOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncRetryFailedResponse>,
      LrOSPutAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncRetryFailedResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRetryFailedOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetryFailedAndWait(
    options?: LrOSPutAsyncRetryFailedOptionalParams
  ): Promise<LrOSPutAsyncRetryFailedResponse> {
    const poller = await this.beginPutAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrycanceled(
    options?: LrOSPutAsyncNoRetrycanceledOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncNoRetrycanceledResponse>,
      LrOSPutAsyncNoRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncNoRetrycanceledResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncNoRetrycanceledOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrycanceledAndWait(
    options?: LrOSPutAsyncNoRetrycanceledOptionalParams
  ): Promise<LrOSPutAsyncNoRetrycanceledResponse> {
    const poller = await this.beginPutAsyncNoRetrycanceled(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
   * header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginPutAsyncNoHeaderInRetry(
    options?: LrOSPutAsyncNoHeaderInRetryOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncNoHeaderInRetryResponse>,
      LrOSPutAsyncNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncNoHeaderInRetryResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncNoHeaderInRetryOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
   * header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginPutAsyncNoHeaderInRetryAndWait(
    options?: LrOSPutAsyncNoHeaderInRetryOptionalParams
  ): Promise<LrOSPutAsyncNoHeaderInRetryResponse> {
    const poller = await this.beginPutAsyncNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutNonResource(
    options?: LrOSPutNonResourceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutNonResourceResponse>,
      LrOSPutNonResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutNonResourceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putNonResourceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutNonResourceAndWait(
    options?: LrOSPutNonResourceOptionalParams
  ): Promise<LrOSPutNonResourceResponse> {
    const poller = await this.beginPutNonResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutAsyncNonResource(
    options?: LrOSPutAsyncNonResourceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncNonResourceResponse>,
      LrOSPutAsyncNonResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncNonResourceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncNonResourceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutAsyncNonResourceAndWait(
    options?: LrOSPutAsyncNonResourceOptionalParams
  ): Promise<LrOSPutAsyncNonResourceResponse> {
    const poller = await this.beginPutAsyncNonResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutSubResource(
    options?: LrOSPutSubResourceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutSubResourceResponse>,
      LrOSPutSubResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutSubResourceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putSubResourceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutSubResourceAndWait(
    options?: LrOSPutSubResourceOptionalParams
  ): Promise<LrOSPutSubResourceResponse> {
    const poller = await this.beginPutSubResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutAsyncSubResource(
    options?: LrOSPutAsyncSubResourceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPutAsyncSubResourceResponse>,
      LrOSPutAsyncSubResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPutAsyncSubResourceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncSubResourceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutAsyncSubResourceAndWait(
    options?: LrOSPutAsyncSubResourceOptionalParams
  ): Promise<LrOSPutAsyncSubResourceResponse> {
    const poller = await this.beginPutAsyncSubResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Accepted200Succeeded(
    options?: LrOSDeleteProvisioning202Accepted200SucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteProvisioning202Accepted200SucceededResponse>,
      LrOSDeleteProvisioning202Accepted200SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteProvisioning202Accepted200SucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteProvisioning202Accepted200SucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Accepted200SucceededAndWait(
    options?: LrOSDeleteProvisioning202Accepted200SucceededOptionalParams
  ): Promise<LrOSDeleteProvisioning202Accepted200SucceededResponse> {
    const poller = await this.beginDeleteProvisioning202Accepted200Succeeded(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202DeletingFailed200(
    options?: LrOSDeleteProvisioning202DeletingFailed200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteProvisioning202DeletingFailed200Response>,
      LrOSDeleteProvisioning202DeletingFailed200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteProvisioning202DeletingFailed200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteProvisioning202DeletingFailed200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202DeletingFailed200AndWait(
    options?: LrOSDeleteProvisioning202DeletingFailed200OptionalParams
  ): Promise<LrOSDeleteProvisioning202DeletingFailed200Response> {
    const poller = await this.beginDeleteProvisioning202DeletingFailed200(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Deletingcanceled200(
    options?: LrOSDeleteProvisioning202Deletingcanceled200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteProvisioning202Deletingcanceled200Response>,
      LrOSDeleteProvisioning202Deletingcanceled200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteProvisioning202Deletingcanceled200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteProvisioning202Deletingcanceled200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Deletingcanceled200AndWait(
    options?: LrOSDeleteProvisioning202Deletingcanceled200OptionalParams
  ): Promise<LrOSDeleteProvisioning202Deletingcanceled200Response> {
    const poller = await this.beginDeleteProvisioning202Deletingcanceled200(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete succeeds and returns right away
   * @param options The options parameters.
   */
  async beginDelete204Succeeded(
    options?: LrOSDelete204SucceededOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete204SucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete succeeds and returns right away
   * @param options The options parameters.
   */
  async beginDelete204SucceededAndWait(
    options?: LrOSDelete204SucceededOptionalParams
  ): Promise<void> {
    const poller = await this.beginDelete204Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202Retry200(
    options?: LrOSDelete202Retry200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDelete202Retry200Response>,
      LrOSDelete202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDelete202Retry200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete202Retry200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202Retry200AndWait(
    options?: LrOSDelete202Retry200OptionalParams
  ): Promise<LrOSDelete202Retry200Response> {
    const poller = await this.beginDelete202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202NoRetry204(
    options?: LrOSDelete202NoRetry204OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDelete202NoRetry204Response>,
      LrOSDelete202NoRetry204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDelete202NoRetry204Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete202NoRetry204OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202NoRetry204AndWait(
    options?: LrOSDelete202NoRetry204OptionalParams
  ): Promise<LrOSDelete202NoRetry204Response> {
    const poller = await this.beginDelete202NoRetry204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a location header in the initial request. Subsequent
   * calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginDeleteNoHeaderInRetry(
    options?: LrOSDeleteNoHeaderInRetryOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteNoHeaderInRetryResponse>,
      LrOSDeleteNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteNoHeaderInRetryResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteNoHeaderInRetryOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a location header in the initial request. Subsequent
   * calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginDeleteNoHeaderInRetryAndWait(
    options?: LrOSDeleteNoHeaderInRetryOptionalParams
  ): Promise<LrOSDeleteNoHeaderInRetryResponse> {
    const poller = await this.beginDeleteNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns an Azure-AsyncOperation header in the initial request.
   * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoHeaderInRetry(
    options?: LrOSDeleteAsyncNoHeaderInRetryOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteAsyncNoHeaderInRetryResponse>,
      LrOSDeleteAsyncNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteAsyncNoHeaderInRetryResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncNoHeaderInRetryOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns an Azure-AsyncOperation header in the initial request.
   * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoHeaderInRetryAndWait(
    options?: LrOSDeleteAsyncNoHeaderInRetryOptionalParams
  ): Promise<LrOSDeleteAsyncNoHeaderInRetryResponse> {
    const poller = await this.beginDeleteAsyncNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrySucceeded(
    options?: LrOSDeleteAsyncRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteAsyncRetrySucceededResponse>,
      LrOSDeleteAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteAsyncRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrySucceededAndWait(
    options?: LrOSDeleteAsyncRetrySucceededOptionalParams
  ): Promise<LrOSDeleteAsyncRetrySucceededResponse> {
    const poller = await this.beginDeleteAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoRetrySucceeded(
    options?: LrOSDeleteAsyncNoRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteAsyncNoRetrySucceededResponse>,
      LrOSDeleteAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteAsyncNoRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncNoRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoRetrySucceededAndWait(
    options?: LrOSDeleteAsyncNoRetrySucceededOptionalParams
  ): Promise<LrOSDeleteAsyncNoRetrySucceededResponse> {
    const poller = await this.beginDeleteAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetryFailed(
    options?: LrOSDeleteAsyncRetryFailedOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteAsyncRetryFailedResponse>,
      LrOSDeleteAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteAsyncRetryFailedResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRetryFailedOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetryFailedAndWait(
    options?: LrOSDeleteAsyncRetryFailedOptionalParams
  ): Promise<LrOSDeleteAsyncRetryFailedResponse> {
    const poller = await this.beginDeleteAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrycanceled(
    options?: LrOSDeleteAsyncRetrycanceledOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSDeleteAsyncRetrycanceledResponse>,
      LrOSDeleteAsyncRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSDeleteAsyncRetrycanceledResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRetrycanceledOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrycanceledAndWait(
    options?: LrOSDeleteAsyncRetrycanceledOptionalParams
  ): Promise<LrOSDeleteAsyncRetrycanceledResponse> {
    const poller = await this.beginDeleteAsyncRetrycanceled(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header.
   * Poll returns a 200 with a response body after success.
   * @param options The options parameters.
   */
  async beginPost200WithPayload(
    options?: LrOSPost200WithPayloadOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPost200WithPayloadResponse>,
      LrOSPost200WithPayloadResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPost200WithPayloadResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post200WithPayloadOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header.
   * Poll returns a 200 with a response body after success.
   * @param options The options parameters.
   */
  async beginPost200WithPayloadAndWait(
    options?: LrOSPost200WithPayloadOptionalParams
  ): Promise<LrOSPost200WithPayloadResponse> {
    const poller = await this.beginPost200WithPayload(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' and
   * 'Retry-After' headers, Polls return a 200 with a response body after success
   * @param options The options parameters.
   */
  async beginPost202Retry200(
    options?: LrOSPost202Retry200OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPost202Retry200Response>,
      LrOSPost202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPost202Retry200Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202Retry200OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' and
   * 'Retry-After' headers, Polls return a 200 with a response body after success
   * @param options The options parameters.
   */
  async beginPost202Retry200AndWait(
    options?: LrOSPost202Retry200OptionalParams
  ): Promise<LrOSPost202Retry200Response> {
    const poller = await this.beginPost202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
   * with noresponse body after success
   * @param options The options parameters.
   */
  async beginPost202NoRetry204(
    options?: LrOSPost202NoRetry204OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPost202NoRetry204Response>,
      LrOSPost202NoRetry204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPost202NoRetry204Response> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202NoRetry204OperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
   * with noresponse body after success
   * @param options The options parameters.
   */
  async beginPost202NoRetry204AndWait(
    options?: LrOSPost202NoRetry204OptionalParams
  ): Promise<LrOSPost202NoRetry204Response> {
    const poller = await this.beginPost202NoRetry204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalLocationGet(
    options?: LrOSPostDoubleHeadersFinalLocationGetOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostDoubleHeadersFinalLocationGetResponse>,
      LrOSPostDoubleHeadersFinalLocationGetResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostDoubleHeadersFinalLocationGetResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postDoubleHeadersFinalLocationGetOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalLocationGetAndWait(
    options?: LrOSPostDoubleHeadersFinalLocationGetOptionalParams
  ): Promise<LrOSPostDoubleHeadersFinalLocationGetResponse> {
    const poller = await this.beginPostDoubleHeadersFinalLocationGet(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGet(
    options?: LrOSPostDoubleHeadersFinalAzureHeaderGetOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostDoubleHeadersFinalAzureHeaderGetResponse>,
      LrOSPostDoubleHeadersFinalAzureHeaderGetResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostDoubleHeadersFinalAzureHeaderGetResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postDoubleHeadersFinalAzureHeaderGetOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "azure-async-operation"
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetAndWait(
    options?: LrOSPostDoubleHeadersFinalAzureHeaderGetOptionalParams
  ): Promise<LrOSPostDoubleHeadersFinalAzureHeaderGetResponse> {
    const poller = await this.beginPostDoubleHeadersFinalAzureHeaderGet(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object if you support initial Autorest behavior.
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetDefault(
    options?: LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultResponse
      >,
      LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object if you support initial Autorest behavior.
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetDefaultAndWait(
    options?: LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams
  ): Promise<LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultResponse> {
    const poller = await this.beginPostDoubleHeadersFinalAzureHeaderGetDefault(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrySucceeded(
    options?: LrOSPostAsyncRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostAsyncRetrySucceededResponse>,
      LrOSPostAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostAsyncRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrySucceededAndWait(
    options?: LrOSPostAsyncRetrySucceededOptionalParams
  ): Promise<LrOSPostAsyncRetrySucceededResponse> {
    const poller = await this.beginPostAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncNoRetrySucceeded(
    options?: LrOSPostAsyncNoRetrySucceededOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostAsyncNoRetrySucceededResponse>,
      LrOSPostAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostAsyncNoRetrySucceededResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncNoRetrySucceededOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncNoRetrySucceededAndWait(
    options?: LrOSPostAsyncNoRetrySucceededOptionalParams
  ): Promise<LrOSPostAsyncNoRetrySucceededResponse> {
    const poller = await this.beginPostAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetryFailed(
    options?: LrOSPostAsyncRetryFailedOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostAsyncRetryFailedResponse>,
      LrOSPostAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostAsyncRetryFailedResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRetryFailedOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetryFailedAndWait(
    options?: LrOSPostAsyncRetryFailedOptionalParams
  ): Promise<LrOSPostAsyncRetryFailedResponse> {
    const poller = await this.beginPostAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrycanceled(
    options?: LrOSPostAsyncRetrycanceledOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrOSPostAsyncRetrycanceledResponse>,
      LrOSPostAsyncRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrOSPostAsyncRetrycanceledResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRetrycanceledOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrycanceledAndWait(
    options?: LrOSPostAsyncRetrycanceledOptionalParams
  ): Promise<LrOSPostAsyncRetrycanceledResponse> {
    const poller = await this.beginPostAsyncRetrycanceled(options);
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const put200SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const patch200SucceededIgnoreHeadersOperationSpec: coreClient.OperationSpec = {
  path: "/lro/patch/200/succeeded/ignoreheaders",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPatch200SucceededIgnoreHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPatch200SucceededIgnoreHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPatch200SucceededIgnoreHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPatch200SucceededIgnoreHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put201SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const post202ListOperationSpec: coreClient.OperationSpec = {
  path: "/lro/list",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    201: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    202: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    204: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const put200SucceededNoStateOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/succeeded/nostate",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/202/retry/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put201CreatingSucceeded200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/creating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put200UpdatingSucceeded204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/updating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put201CreatingFailed200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/created/failed/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put200Acceptedcanceled200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/accepted/canceled/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/noheader/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutNoHeaderInRetryHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutNoHeaderInRetryHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutNoHeaderInRetryHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/retry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetrySucceededHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetrySucceededHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetrySucceededHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noretry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrySucceededHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrySucceededHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrySucceededHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/retry/failed",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetryFailedHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetryFailedHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetryFailedHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncNoRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noretry/canceled",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrycanceledHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrycanceledHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrycanceledHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noheader/201/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoHeaderInRetryHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoHeaderInRetryHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoHeaderInRetryHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPutAsyncNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putNonResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putnonresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncNonResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putnonresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putSubResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putsubresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct
    },
    201: {
      bodyMapper: Mappers.SubProduct
    },
    202: {
      bodyMapper: Mappers.SubProduct
    },
    204: {
      bodyMapper: Mappers.SubProduct
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncSubResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putsubresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct
    },
    201: {
      bodyMapper: Mappers.SubProduct
    },
    202: {
      bodyMapper: Mappers.SubProduct
    },
    204: {
      bodyMapper: Mappers.SubProduct
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const deleteProvisioning202Accepted200SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/provisioning/202/accepted/200/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteProvisioning202DeletingFailed200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/provisioning/202/deleting/200/failed",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteProvisioning202Deletingcanceled200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/provisioning/202/deleting/200/canceled",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const delete204SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/204/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const delete202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/202/retry/200",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const delete202NoRetry204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/202/noretry/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/noheader",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteNoHeaderInRetryHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteNoHeaderInRetryHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteNoHeaderInRetryHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/noheader/202/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteAsyncNoHeaderInRetryHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteAsyncNoHeaderInRetryHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteAsyncNoHeaderInRetryHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteAsyncNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrySucceededHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrySucceededHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrySucceededHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/noretry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteAsyncNoRetrySucceededHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteAsyncNoRetrySucceededHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteAsyncNoRetrySucceededHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteAsyncNoRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/failed",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteAsyncRetryFailedHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteAsyncRetryFailedHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteAsyncRetryFailedHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/canceled",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrycanceledHeaders
    },
    201: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrycanceledHeaders
    },
    202: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrycanceledHeaders
    },
    204: {
      headersMapper: Mappers.LrOSDeleteAsyncRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const post200WithPayloadOperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/payload/200",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const post202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/202/retry/200",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrOSPost202Retry200Headers
    },
    201: {
      headersMapper: Mappers.LrOSPost202Retry200Headers
    },
    202: {
      headersMapper: Mappers.LrOSPost202Retry200Headers
    },
    204: {
      headersMapper: Mappers.LrOSPost202Retry200Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const post202NoRetry204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/202/noretry/204",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPost202NoRetry204Headers
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPost202NoRetry204Headers
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPost202NoRetry204Headers
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrOSPost202NoRetry204Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postDoubleHeadersFinalLocationGetOperationSpec: coreClient.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalLocationGet",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const postDoubleHeadersFinalAzureHeaderGetOperationSpec: coreClient.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGet",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec: coreClient.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.accept],
  serializer
};
const postAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/noretry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/failed",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrOSPostAsyncRetryFailedHeaders
    },
    201: {
      headersMapper: Mappers.LrOSPostAsyncRetryFailedHeaders
    },
    202: {
      headersMapper: Mappers.LrOSPostAsyncRetryFailedHeaders
    },
    204: {
      headersMapper: Mappers.LrOSPostAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/canceled",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrOSPostAsyncRetrycanceledHeaders
    },
    201: {
      headersMapper: Mappers.LrOSPostAsyncRetrycanceledHeaders
    },
    202: {
      headersMapper: Mappers.LrOSPostAsyncRetrycanceledHeaders
    },
    204: {
      headersMapper: Mappers.LrOSPostAsyncRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.Host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
