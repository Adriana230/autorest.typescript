@using System.Linq;
@using AutoRest.Core.Model
@using AutoRest.TypeScript
@using AutoRest.TypeScript.Model
@inherits AutoRest.Core.Template<AutoRest.TypeScript.Model.MethodTS>
// Send Request
let operationRes: msRest.HttpOperationResponse;
try {
@if (Model.RequestBody != null)
{
<text>
  @(Model.ConstructRequestBodyMapper)
</text>
}
  operationRes = await client.sendOperationRequest(
    httpRequest,
    {
      arguments: {
@foreach (Parameter parameter in Model.LogicalParameters)
{
<text>
        "@(parameter.Name)": @(parameter.Name),
</text>
}
      },
      abortSignal: options && options.abortSignal,
      customHeaders: options && options.customHeaders
    },
    {
      httpMethod: "@(Model.HttpMethod.ToString().ToUpper())",
@if (Model.IsAbsoluteUrl)
{
<text>
      baseUrl: "@(Model.Url)",
</text>
}
else
{
<text>
      baseUrl: @(Model.ClientReference).baseUri,
      path: "@(Model.Url)",
</text>
}
@if (Model.LogicalParameters.Any(p => p.Location == ParameterLocation.Path))
{
<text>
      urlParameters: [
@foreach (ParameterTS pathParameter in Model.LogicalParameters.Where(p => p.Location == ParameterLocation.Path))
{
<text>
        {
          parameterName: "@(pathParameter.Name)",
@if (pathParameter.Name != pathParameter.SerializedName)
{
<text>
          urlParameterName: "@(pathParameter.SerializedName)",
</text>
}
@if (pathParameter.OperationType != null)
{
<text>
          type: msRest.OperationParameterType.@(pathParameter.OperationType),
</text>
}
@if (pathParameter.SkipUrlEncoding())
{
<text>
          skipEncoding: true,
</text>
}
        },
</text>
}
      ],
</text>
}
@if (Model.LogicalParameters.Any(p => p.Location == ParameterLocation.Query))
{
<text>
      queryParameters: [
@foreach (ParameterTS queryParameter in Model.LogicalParameters.Where(p => p.Location == ParameterLocation.Query))
{
<text>
        {
          parameterName: "@(queryParameter.Name)",
@if (queryParameter.Name != queryParameter.SerializedName)
{
<text>
          queryParameterName: "@(queryParameter.SerializedName)",
</text>
}
@if (queryParameter.SkipUrlEncoding())
{
<text>
          skipEncoding: true,
</text>
}
@if (queryParameter.CollectionFormat != CollectionFormat.None)
{
<text>
          collectionFormat: msRest.QueryCollectionFormat.@(queryParameter.CollectionFormat),
</text>
}
@if (queryParameter.OperationType != null)
{
<text>
          type: msRest.OperationParameterType.@(queryParameter.OperationType),
</text>
}
        },
</text>
}
      ],
</text>
}
@if (Model.LogicalParameters.Any(p => p.Location == ParameterLocation.Header))
{
<text>
      headerParameters: [
@foreach (ParameterTS parameter in Model.LogicalParameters.Where(p => p.Location == ParameterLocation.Header))
{
<text>
        {
          parameterName: "@(parameter.Name)",
@if (parameter.Name != parameter.SerializedName)
{
<text>
          headerName: "@(parameter.SerializedName)",
</text>
}
@if (parameter.OperationType != null)
{
<text>
          type: msRest.OperationParameterType.@(parameter.OperationType),
</text>
}
        },
</text>
}
      ],
</text>
}
@if (Model.RequestBody != null)
{
<text>
      requestBodyMapper: requestModelMapper,
      requestBodyName: "@(Model.RequestBody.Name)",
@if (Model.RequestBody.OperationType != null)
{
<text>
      requestBodyType: msRest.OperationParameterType.@(Model.RequestBody.OperationType),
</text>
}
      contentType: "@(Model.RequestContentType)",
</text>
}
else if (Model.LogicalParameters.Where(p => p.Location == ParameterLocation.FormData).Any())
{
<text>
      formDataParameters: [
@foreach (ParameterTS formDataParameter in Model.LogicalParameters.Where(p => p.Location == ParameterLocation.FormData))
{
<text>
        {
          parameterName: "@(formDataParameter.Name)",
@if (formDataParameter.Name != formDataParameter.SerializedName)
{
<text>
          formDataPropertyName: "@(formDataParameter.SerializedName)",
</text>
}
@if (formDataParameter.OperationType != null)
{
<text>
          type: msRest.OperationParameterType.@(formDataParameter.OperationType),
</text>
}
        },
</text>
}
      ],
      contentType: "@(Model.RequestContentType)",
</text>
}
@if (Model.CodeModel.ShouldGenerateXmlSerialization)
{
<text>
      isXML: true,
</text>
}
    });
  let statusCode = operationRes.status;
  if (@(Model.FailureStatusCodePredicate)) {
    let error = new msRest.RestError(operationRes.bodyAsText as string);
    error.statusCode = operationRes.status;
    error.request = msRest.stripRequest(httpRequest);
    error.response = msRest.stripResponse(operationRes);
    let parsedErrorResponse = operationRes.parsedBody as { [key: string]: any };
    try {
      if (parsedErrorResponse) {
        @(Model.PopulateErrorCodeAndMessage())
      }
  @if (Model.DefaultResponse.Body != null)
  {
      var deserializeErrorBody = Model.GetDeserializationString(Model.DefaultResponse.Body, "error.body", "parsedErrorResponse");
      if (!string.IsNullOrWhiteSpace(deserializeErrorBody))
      {
@:      if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
@:        @(deserializeErrorBody)
@:      }
      }
  }
    } catch (defaultError) {
      error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                       `- "${operationRes.bodyAsText}" for the default response.`;
      return Promise.reject(error);
    }
    return Promise.reject(error);
  }
  @Model.InitializeResult
  @foreach (var responsePair in Model.Responses.Where(r => r.Value.Body != null || r.Value.Headers != null))
  {
      <text>
  // Deserialize Response
  if (statusCode === @MethodTS.GetStatusCodeReference(responsePair.Key)) {
@if (responsePair.Value.Body != null) {
@:    @(Model.DeserializeResponse(responsePair.Value.Body, "operationRes.parsedBody"))
}
@if (responsePair.Value.Headers != null) {
@:    operationRes.parsedHeaders = client.serializer.deserialize(Mappers.@(responsePair.Value.Headers.Name), operationRes.headers.rawHeaders(), 'operationRes.parsedBody');
}
  }
      </text>
  }
  @if (Model.ReturnType.Body != null && Model.DefaultResponse.Body != null && !Model.Responses.Any())
  {
    @(Model.DeserializeResponse(Model.DefaultResponse.Body, "operationRes.parsedBody"))
  }
@EmptyLine
} catch(err) {
  return Promise.reject(err);
}
@EmptyLine
return Promise.resolve(operationRes);